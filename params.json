{"name":"Spray-funnel","tagline":"AKKA based utility throttle traffic in a Spray Client or Server Application   ","body":"Spray Funnel\r\n====================\r\n\r\nSpray Client extension to allow limitation of client request frequency and number of parallel requests\r\n\r\n[![Build Status](https://api.travis-ci.org/galarragas/spray-funnel.png)](http://travis-ci.org/galarragas/spray-funnel)\r\n\r\n![Image](https://github.com/galarragas/spray-funnel/raw/master/funnel.jpg?raw=true)\r\n\r\n## What is it?\r\n\r\nSpray Funnel is a request throttling system for AKKA actors that has been specifically designed to support HttpRequest - HttpReply interactions.\r\nIt can be easily extended to support different protocols but at the moment is tested for HTTP-based interactions.\r\nIt can be seen as an extension of the AKKA Throttler feature (http://doc.akka.io/docs/akka/snapshot/contrib/throttle.html#introduction)\r\nsupporting Request-Reply patterns in order to provide a slightly wider set of features. It allows to limit:\r\n\r\n- The number of request per specified interval\r\n- Number of parallel active requests\r\n- Timeout after which an enqueued request has to be discarded\r\n- Maximum number of messages enqueued after which new incoming messages are discarded until the queue size decreases (limiting spikes)\r\n\r\nIt supports throttling of Spray Client code and Spray Server code\r\n\r\n### Spray Client\r\nThe idea is to create a generic mechanism to allow the throttling of all the messages sent and received by a `sendReceive` Spray pipeline.\r\nThe work can be easily generalised for different protocols but at the moment I'm using it with for HTTP requests.\r\n\r\nAs default uses the HTTP transport but offers the possibility of specifying a custom transport\r\n\r\nWhen a client request is discarded because of a timeout or because of too many enqueued requests to be served,\r\na notification is sent to the Actor System `eventBus` in the form of a `DiscardedClientRequest` object containing the discarded\r\nrequest and the reason. If a request is not served in the specified request timeout an `FailedClientRequest` object is published\r\nin the Actor System `eventBus`\r\n\r\n### Spray Server\r\n\r\nSpray Funnel can be used to limit the amount of parallel request and the frequency of request to be served by an HTTP Server Request Handler\r\nsimilarly to the Jetty QoS filter (http://wiki.eclipse.org/Jetty/Reference/QoSFilter).\r\n\r\nAll requests not forwarded to the HTTP Server Request Handler because of timeout or queue threshold limit are rejected with an\r\n`HttpResponse(BandwidthLimitExceeded)`. This will prevent the `Timedout` notification from Spray.\r\nIn a similar fashion, all requests not served by the HTTP Server Request Handler within the specified request timeout will be completed\r\n with a `HttpResponse(InternalServerError)` response.\r\n\r\n## Usage\r\n\r\n### Spray Client\r\n\r\nThere are two main types of usage of the library: creating a throttling actor during the pipeline definition to wrap the HTTP transport or using AKKA extensions\r\n\r\n### Inline Wrapping of HTTP Actor Passed to `sendReceive`\r\n\r\nA very simple way of using this library is to specify the throttling setting in the sendReceive pipeline definition like shown below\r\n\r\n```scala\r\nclass SimpleSprayClient(serverBaseAddress: String timeout: Timeout) {\r\n  import SimpleClientProtocol._\r\n  import com.pragmasoft.reactive.throttling.http.HttpRequestThrottling._\r\n\r\n  implicit val actorSystem = ActorSystem(\"program-info-client\", ConfigFactory.parseResources(\"test.conf\"))\r\n\r\n  import actorSystem.dispatcher\r\n\r\n  implicit val apiTimeout : Timeout = timeout\r\n\r\n  val pipeline = sendReceive(throttleFrequencyAndParallelRequests(30 perSecond, 10)) ~> unmarshal[SimpleResponse]\r\n\r\n  def callFakeService(id: Int) : Future[SimpleResponse] = pipeline { Get(s\"$serverBaseAddress/fakeService?$id\") }\r\n\r\n\r\n  def shutdown() = actorSystem.shutdown()\r\n}\r\n```\r\n\r\nThe object `com.pragmasoft.reactive.throttling.client.HttpClientThrottling` exports the following methods:\r\n\r\n- `throttleFrequency` to throttle the http traffic frequency only\r\n- `throttleFrequencyAndParallelRequests` to throttle the http traffic frequency only\r\n- `throttleWithConfig` to specify more complex configuration (see section below about extensions to see a decription of the configuration options)\r\n\r\nIt is also possible to specify a transport different than HTTP with the methods `throttleFrequencyWithTransport`,\r\n`throttleFrequencyAndParallelRequestWithTransport`, `throttleWithConfigAndTransport`\r\n\r\n\r\n### Using AKKA Extensions\r\n\r\nThis mechanism allows the same throttling channel to be shared by different pipelines, thus allowing to limit the\r\nthroughput of an application talking with destinations shared by different client classes or traits.\r\n\r\nTo enable this feature you need to create an AKKA extension. This is very simple and is just a matter of implementing\r\ntwo classes as in the example below:\r\n\r\n```scala\r\nclass TestFunneledChannelExtension(val system: ExtendedActorSystem) extends FunneledChannelExtension {\r\n  lazy val configRootName = \"qos.channels.channel1\"\r\n}\r\n\r\nobject TestFunneledChannel extends ExtensionKey[TestFunneledChannelExtension]\r\n```\r\n\r\nHaving defined the extension the Spray Client code will be written as follows:\r\n\r\n```scala\r\nclass SimpleSprayClient(serverBaseAddress: String, timeout : Timeout ) {\r\n\r\n  implicit val actorSystem = ActorSystem(\"simple-spray-client\", ConfigFactory.parseResources(\"test.conf\"))\r\n  import actorSystem.dispatcher\r\n\r\n  implicit val futureTimeout : Timeout = timeout\r\n\r\n  val pipeline = sendReceive(IO(TestFunneledChannel)) ~> unmarshal[SimpleResponse]\r\n\r\n  def callFakeService(id: Int) : Future[SimpleResponse] = pipeline { Get(s\"$serverBaseAddress/fakeService?$id\") }\r\n\r\n  def shutdown() = actorSystem.shutdown()\r\n}\r\n```\r\n\r\nThe reference to `IO(TestFunneledChannel)` allows AKKA to retrieve the configuration of your channel and apply it to\r\nlimit the traffic of your pipeline\r\n\r\nThe AKKA configuration will be written as follows:\r\n\r\n```\r\nqos.channels {\r\n    channel1 {\r\n        frequency {\r\n            threshold = 5\r\n            interval = 15 s\r\n        }\r\n        requests {\r\n            # Max number of request active at the same time on this channel\r\n            # parallel-threshold = infinite disables parallel request limit\r\n            parallel-threshold = 3\r\n            # Max timeout waiting for the response of any request. Should be a finite value\r\n            timeout = 45 s\r\n            # Interval after which not served request will be discarded\r\n            expiry = infinite\r\n            # If set to a finite value will cause to discard all messages received when the queue of not served\r\n            # messages is higher than the threshold\r\n            max-queue-size = infinite\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### Spray Server\r\n\r\nAt the moment the only supported pattern is using a singleton handler, since the wrapping funneling actor is only able to\r\nserve one target.\r\n\r\nA sample usage is:\r\n\r\n```scala\r\n\r\nimport com.pragmasoft.reactive.throttling.http.server.HttpServerThrottling._\r\n\r\nclass StubServer(interface: String, port: Int) extends Actor {\r\n  IO(Http).ask(Http.Bind(service, interface, port))(3.seconds)\r\n\r\n  val allConnectionsHandler = throttleFrequencyAndParallelRequests(30 perSecond, 10) { system.actorOf(... my http handler actor props here) }\r\n\r\n  override def receive: Actor.Receive = {\r\n    case Http.Connected(peer, _) â‡’\r\n      log.debug(\"Connected with {}\", peer)\r\n      sender ! Http.Register(allConnectionsHandler)\r\n  }\r\n}\r\n\r\n```\r\n\r\nThe object `com.pragmasoft.reactive.throttling.server.HttpServerThrottling` exports the following methods:\r\n\r\n- `throttleFrequency` to throttle the http traffic frequency only\r\n- `throttleFrequencyAndParallelRequests` to throttle the http traffic frequency only\r\n- `throttleWithConfig` to specify more complex configuration (see section about client throttling with AKKA extensions to see a description of the configuration options)\r\n\r\n\r\n### Settings already available in Spray\r\nThe parallel request limitation can be done in Spray using the `spray.can.server.pipelining-limit` parameter. This setting\r\nwill limit the number of active request per connection. The throttling available using spray-funnel instead can be used across\r\nconnections using the singleton pattern or with more sophisticated logic as for example one throttle per IP address just\r\nusing different funnels.\r\n\r\n## Adding Dependency to Spray Funnel\r\n\r\nAdd conjars repository to your resolvers:\r\n\r\n```\r\nresolvers += \"ConJars\" at \"http://conjars.org/repo\",\r\n```\r\n\r\nthen add the following dependencies to your sbt configuration\r\n\r\n```\r\nlibraryDependencies += \"com.pragmasoft\" %% \"spray-funnel\" % \"1.0-RC2\"\r\n```\r\n\r\n## Dependencies:\r\n\r\nRuntime:\r\n\r\n- Scala 2.10\r\n- Spray Client 1.2.0\r\n- Akka 2.2.3\r\n\r\nTest:\r\n\r\n- Akka_testkit 2.2.3\r\n- Specs2 2.2.3\r\n\r\n## License\r\n\r\nCopyright 2014 PragmaSoft Ltd.\r\n\r\nLicensed under the Apache License, Version 2.0: http://www.apache.org/licenses/LICENSE-2.0\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}